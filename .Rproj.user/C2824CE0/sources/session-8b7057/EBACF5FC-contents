alfa.mad <- function(y, x, a = 0.5, start = NULL, xnew = NULL, yb = NULL) {
  
  runtime <- proc.time()

  n <- dim(y)[1]
  D <- dim(y)[2]  ;   d <- D - 1
  p <- dim(x)[2]
  
  if ( is.null(yb) ) {
    ya <- Compositional::alfa(y, a)$aff
  } else  ya <- yb
  x <- model.matrix(y ~ ., data = as.data.frame(x)) 
  y_vec <- as.vector( t(ya) )
  
  n_params <- d * p
  param_names <- paste0("b", 1:n_params)
  df <- data.frame( y = y_vec, row = rep(1:n, each = d), comp = rep(1:d, times = n) )
  for ( j in 1:p )  df[[ paste0("X", j) ]] <- rep(x[, j], each = d)
 
  predict_mu_alpha_vectorized <- function(...) {
    params_vec <- unlist(list(...))
    beta_matrix <- matrix(params_vec, nrow = d, ncol = p, byrow = TRUE)
    est <- cbind(1, exp(x %*% t( beta_matrix) ) )
    est <- est / Rfast::rowsums(est)
    ma <- Compositional::alfa(est, a)$aff
    as.vector( t(ma) )
  }

  # Better starting values - scale them down to avoid initial overflow
  if ( is.null(start) ) {
    start_raw <- solve( crossprod(x), crossprod(x, ya) )
    start <- as.vector( t(start_raw) ) * 0.5  # Scale down by 50%
  }
  # Check starting values and use small values if starting values are bad
  if ( any( !is.finite(start) ) )  start <- rep(0.01, n_params)  
  start_vals <- as.list(start)
  names(start_vals) <- param_names
  formula_str <- paste0( "y ~ predict_mu_alpha_vectorized(", 
                         paste(param_names, collapse = ", "), ")" )
  fit <- NULL
  fit <- tryCatch({
         quantreg::nlrq( formula = as.formula(formula_str), data = df, start = start_vals, trace = FALSE,
         control = quantreg::nlrq.control( maxiter = 5000, InitialStepSize = 0.1, eps = 1e-4) )
    }, error = function(e) {
      message("nlrq failed: ", e$message)
      NULL
    })
  
  if ( is.null(fit) )  stop( "The optimization failed. Check your data and starting values." )
  
  # Extract coefficients as matrix
  coef_vec <- coef(fit)
  be <- matrix(coef_vec, nrow = d, ncol = p, byrow = TRUE)
  rownames(be) <- paste0("Y", 2:D)
  colnames(be) <- colnames(x)
  be <- t(be)
   
  runtime <- proc.time() - runtime

  est <- NULL
  if ( !is.null(xnew) ) {
    xnew <- model.matrix(~., data.frame(xnew) )
    est <- cbind( 1, exp(xnew %*% be) )
    est <- est/Rfast::rowsums(est)
  }

  list( runtime = runtime, be = be, est = est )
}



