alfa.mad <- function(y, x, a = 0.5, start = NULL, coords, k = 10, xnew = NULL, yb = NULL) {

  runtime <- proc.time()

  W <- CompositionalSR::contiguity(coords, k)
  if ( is.null(yb) ) {
    ya <- Compositional::alfa(y, a)$aff
  } else  ya <- yb
  x <- model.matrix( y ~ ., data = as.data.frame(x) )
  Wx <- W %*% x[, -1]
  X <- cbind(x, Wx)
  y_vec <- as.vector( t(ya) )

  n <- dim(y)[1]
  D <- dim(y)[2]  ;   d <- D - 1
  p <- dim(X)[2]

  n_params <- d * p
  param_names <- paste0("b", 1:n_params)
  df <- data.frame( y = y_vec, row = rep(1:n, each = d), comp = rep(1:d, times = n) )
  for ( j in 1:p )  df[[ paste0("X", j) ]] <- rep(X[, j], each = d)

  predict_mu_alpha_vectorized <- function(...) {
    params_vec <- unlist(list(...))
    beta_matrix <- matrix(params_vec, nrow = d, ncol = p, byrow = TRUE)
    est <- cbind(1, exp(X %*% t( beta_matrix) ) )
    est <- est / Rfast::rowsums(est)
    ma <- Compositional::alfa(est, a)$aff
    as.vector( t(ma) )
  }

  # Better starting values - scale them down to avoid initial overflow
  if ( is.null(start) ) {
    start_raw <- solve( crossprod(X), crossprod(X, ya) )
    start <- as.vector( t(start_raw) ) * 0.5  # Scale down by 50%
  }
  # Check starting values and use small values if starting values are bad
  if ( any( !is.finite(start) ) )  start <- rep(0.01, n_params)
  start_vals <- as.list(start)
  names(start_vals) <- param_names
  formula_str <- paste0( "y ~ predict_mu_alpha_vectorized(",
                         paste(param_names, collapse = ", "), ")" )
  fit <- NULL
  fit <- tryCatch({
         quantreg::nlrq( formula = as.formula(formula_str), data = df, start = start_vals, trace = FALSE,
         control = quantreg::nlrq.control( maxiter = 5000, InitialStepSize = 0.1, eps = 1e-4) )
    }, error = function(e) {
      message("nlrq failed: ", e$message)
      NULL
    })

  if ( is.null(fit) )  stop( "The optimization failed. Check your data and starting values." )

  # Extract coefficients as matrix
  coef_vec <- coef(fit)
  be <- matrix(coef_vec, nrow = d, ncol = p, byrow = TRUE)
  rownames(be) <- paste0("Y", 2:D)
  colnames(be) <- colnames(x)
  be <- t(be)

  runtime <- proc.time() - runtime

  est <- NULL
  if ( !is.null(xnew) ) {
    cordsnew <- pi * coordsnew / 180  ## from degrees to rads
    a1 <- sin(cordsnew[, 1])
    coordnew <- cbind( cos(cordsnew[, 1]), a1 * cos(cordsnew[, 2]), a1 * sin(cordsnew[, 2]) )
    cords <- pi * coords / 180  ## from degrees to rads
    a1 <- sin(cords[, 1])
    coord <- cbind( cos(cords[, 1]), a1 * cos(cords[, 2]), a1 * sin(cords[, 2]) )
    Wnew <- Rfast::dista(coordnew, coord, square = TRUE)

    b <- Rfast::rowOrder(Wnew)
    b[b > k + 1] <- 0
    b[b > 0] <- 1
    Wnew <- 1 / Wnew
    Wnew[ is.infinite(Wnew) ] <- 0
    Wnew <- b * Wnew
    b <- NULL
    Wnew <- Wnew / Rfast::rowsums(Wnew)

    xnew <- model.matrix(~., data.frame(xnew) )
    Wxnew <- Wnew %*% x[, -1]
    xnew <- cbind(xnew, Wxnew)
    est <- cbind( 1, exp(xnew %*% be) )
    est <- est/Rfast::rowsums(est)
  }

  p <- p - 1
  gama <- be[(p + 2) : (2 * p + 1), ]
  be <- be[1:(p + 1), ]

  list( runtime = runtime, be = be, gama = gama, est = est )
}



