alfa.sar <- function(y, x, a, coords, k = 10, xnew = NULL, coordsnew, yb = NULL) {

  rega <- function(para, sw, ya, ax, a, ha, d, D) {
    be <- matrix(para, ncol = d)
    zz <- cbind( 1, exp( sw %*% ax %*% be) )
    ta <- rowSums(zz)
    za <- zz / ta
    ma <- ( D / a * za - 1/a ) %*% ha
    as.vector(ya - ma)
  }

  regarho <- function(rho, para, ya, W, ax, a, ha, d, D) {
    be <- matrix(para, ncol = d)
    if ( abs(rho) > 1e-4 ) {
      sw <- In - rho * W
      zz <- cbind( 1, exp( solve(sw, ax %*% be) ) )
    } else  zz <- cbind( 1, exp( ax %*% be ) )
    ta <- rowSums(zz)
    za <- zz / ta
    ma <- ( D / a * za - 1/a ) %*% ha
    sum( (ya - ma)^2 )
  }

  runtime <- proc.time()

  W <- CompositionalSR::contiguity(coords, k)
  if ( is.null(yb) ) {
    ya <- Compositional::alfa(y, a)$aff
  } else  ya <- yb
  x <- model.matrix( ya ~., data.frame(x) )

  ax <- a * x

  D <- dim(y)[2]
  d <- D - 1  ## dimensionality of the simplex
  n <- dim(x)[1]
  In <- diag(n)

  if ( a <= 1e-5 ) {
    mod <- Compositional::comp.reg(y, x[, -1], yb = yb)
    be <- mod$be

  } else {
    ha <- t( Compositional::helm(D) )
    ini <- as.vector( CompositionalSR::alfa.reg(y, x[, -1], a, yb = ya)$be )
    suppressWarnings({
      mod1 <- optimize( regarho, c(-1, 1), para = ini, ya = ya, W = W, ax = ax, a = a, ha = ha, d = d, D = D,
                        tol = 1e-4 )
      rho <- mod1$minimum
      if ( abs(rho) > 1e-4 ) {
        sw <- solve( In - rho * W )
      } else  sw <- In
      mod2 <- minpack.lm::nls.lm( par = ini, fn = rega, sw = sw, ya = ya, ax = ax, a = a, ha = ha, d = d, D = D,
                                  control = minpack.lm::nls.lm.control(maxiter = 10000) )
      i <- 1
      while (mod1$objective - mod2$deviance > 1e-4) {
        i <- i + 1
        mod1 <- optimize( regarho, c(-1, 1), para = mod2$par, ya = ya, W = W, ax = ax, a = a, ha = ha, d = d, D = D,
                          tol = 1e-4 )
        rho <- mod1$minimum
        if ( abs(rho) > 1e-4 ) {
          sw <- solve( In - rho * W )
        } else  sw <- In
        mod2 <- minpack.lm::nls.lm( par = mod2$par, fn = rega, sw = sw, ya = ya, ax = ax, a = a, ha = ha, d = d, D = D,
                                    control = minpack.lm::nls.lm.control(maxiter = 10000) )
      }

    })

    rho <- mod1$minimum
    be <- matrix(mod2$par, ncol = d)
  }  ## end if (a == 0)

  est <- NULL
  if ( !is.null(xnew) ) {
    xnew <- model.matrix(~., data.frame(xnew) )
    Xaug <- rbind(x, xnew)
    coordsaug <- rbind(coords, coordsnew)
    Waug <- contiguity(coordsaug, k = 10)
    sw <- In - rho * Waug
    zz <- cbind( 1, exp( solve(sw, Xaug %*% be) ) )
    ta <- rowSums(zz)
    est <- zz / ta
    est <- round(est[-c(1:n), ], 10)
  } else {
    sw <- In - rho * W
    zz <- cbind( 1, exp( solve(sw, x %*% be) ) )
    ta <- rowSums(zz)
    est <- zz / ta
    est <- round(est, 9)
  }

  runtime <- proc.time() - runtime

  p <- dim(x)[2] - 1
  if ( is.null( colnames(x) ) ) {
    rownames(be) <- c("constant", paste("X", 1:p, sep = "") )
  } else rownames(be)  <- c("constant", colnames(x)[-1] )

  list(runtime = runtime, rho = rho, be = be, dev = mod2$deviance, est = est)
}
